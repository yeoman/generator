<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Source: index.js | Generator</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css" />
    <link
      type="text/css"
      rel="stylesheet"
      href="styles/prettify-tomorrow.css"
    />
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css" />
  </head>
  <body>
    <nav class="lnb" id="lnb">
      <div class="logo" style="width: 127px; height: 14px;">
        <img
          src="https://raw.githubusercontent.com/yeoman/yeoman.github.io/source/app/assets/img/logo.png"
          width="100%"
          height="100%"
        />
      </div>
      <div class="title">
        <h1><a href="index.html" class="link">Generator</a></h1>

        <span class="version">v4.8.0</span>
      </div>
      <div class="search-container" id="search-container">
        <input type="text" placeholder="Search" />
        <ul></ul>
      </div>

      <div class="lnb-api hidden">
        <h3>Modules</h3>
        <ul>
          <li>
            <a href="module-promptSuggestion.html">promptSuggestion</a
            ><button type="button" class="hidden toggle-subnav btn btn-link">
              <span class="glyphicon glyphicon-plus"></span>
            </button>
            <div class="hidden" id="module:promptSuggestion_sub"></div>
          </li>
        </ul>
      </div>
      <div class="lnb-api hidden">
        <h3>Classes</h3>
        <ul>
          <li>
            <a href="Conflicter.html">Conflicter</a
            ><button type="button" class="hidden toggle-subnav btn btn-link">
              <span class="glyphicon glyphicon-plus"></span>
            </button>
            <div class="hidden" id="Conflicter_sub">
              <div class="member-type">Methods</div>
              <ul class="inner">
                <li>
                  <a href="Conflicter.html#_detectConflict">_detectConflict</a>
                </li>
                <li><a href="Conflicter.html#_printDiff">_printDiff</a></li>
                <li>
                  <a href="Conflicter.html#checkForCollision"
                    >checkForCollision</a
                  >
                </li>
                <li><a href="Conflicter.html#collision">collision</a></li>
                <li><a href="Conflicter.html#resolve">resolve</a></li>
              </ul>
            </div>
          </li>
          <li>
            <a href="Generator.html">Generator</a
            ><button type="button" class="hidden toggle-subnav btn btn-link">
              <span class="glyphicon glyphicon-plus"></span>
            </button>
            <div class="hidden" id="Generator_sub">
              <div class="member-type">Methods</div>
              <ul class="inner">
                <li><a href="Generator.html#argument">argument</a></li>
                <li>
                  <a href="Generator.html#argumentsHelp">argumentsHelp</a>
                </li>
                <li><a href="Generator.html#bowerInstall">bowerInstall</a></li>
                <li>
                  <a href="Generator.html#cancelCancellableTasks"
                    >cancelCancellableTasks</a
                  >
                </li>
                <li><a href="Generator.html#composeWith">composeWith</a></li>
                <li>
                  <a href="Generator.html#createStorage">createStorage</a>
                </li>
                <li><a href="Generator.html#debug">debug</a></li>
                <li><a href="Generator.html#desc">desc</a></li>
                <li>
                  <a href="Generator.html#destinationPath">destinationPath</a>
                </li>
                <li>
                  <a href="Generator.html#destinationRoot">destinationRoot</a>
                </li>
                <li>
                  <a href="Generator.html#determineAppname">determineAppname</a>
                </li>
                <li><a href="Generator.html#git.email">git.email</a></li>
                <li><a href="Generator.html#help">help</a></li>
                <li>
                  <a href="Generator.html#installDependencies"
                    >installDependencies</a
                  >
                </li>
                <li><a href="Generator.html#git.name">git.name</a></li>
                <li><a href="Generator.html#npmInstall">npmInstall</a></li>
                <li><a href="Generator.html#option">option</a></li>
                <li><a href="Generator.html#optionsHelp">optionsHelp</a></li>
                <li><a href="Generator.html#prompt">prompt</a></li>
                <li><a href="Generator.html#queueMethod">queueMethod</a></li>
                <li><a href="Generator.html#queueTask">queueTask</a></li>
                <li>
                  <a href="Generator.html#queueTaskGroup">queueTaskGroup</a>
                </li>
                <li>
                  <a href="Generator.html#registerTransformStream"
                    >registerTransformStream</a
                  >
                </li>
                <li>
                  <a href="Generator.html#rootGeneratorName"
                    >rootGeneratorName</a
                  >
                </li>
                <li>
                  <a href="Generator.html#rootGeneratorVersion"
                    >rootGeneratorVersion</a
                  >
                </li>
                <li><a href="Generator.html#run">run</a></li>
                <li>
                  <a href="Generator.html#scheduleInstallTask"
                    >scheduleInstallTask</a
                  >
                </li>
                <li><a href="Generator.html#sourceRoot">sourceRoot</a></li>
                <li><a href="Generator.html#spawnCommand">spawnCommand</a></li>
                <li>
                  <a href="Generator.html#spawnCommandSync">spawnCommandSync</a>
                </li>
                <li><a href="Generator.html#templatePath">templatePath</a></li>
                <li><a href="Generator.html#usage">usage</a></li>
                <li>
                  <a href="Generator.html#github.username">github.username</a>
                </li>
                <li><a href="Generator.html#yarnInstall">yarnInstall</a></li>
              </ul>
            </div>
          </li>
          <li>
            <a href="Storage.html">Storage</a
            ><button type="button" class="hidden toggle-subnav btn btn-link">
              <span class="glyphicon glyphicon-plus"></span>
            </button>
            <div class="hidden" id="Storage_sub">
              <div class="member-type">Methods</div>
              <ul class="inner">
                <li><a href="Storage.html#defaults">defaults</a></li>
                <li><a href="Storage.html#delete">delete</a></li>
                <li><a href="Storage.html#get">get</a></li>
                <li><a href="Storage.html#getAll">getAll</a></li>
                <li><a href="Storage.html#getPath">getPath</a></li>
                <li><a href="Storage.html#save">save</a></li>
                <li><a href="Storage.html#set">set</a></li>
                <li><a href="Storage.html#setPath">setPath</a></li>
              </ul>
            </div>
          </li>
        </ul>
      </div>
      <div class="lnb-api hidden">
        <h3>Mixins</h3>
        <ul>
          <li>
            <a href="actions_help.html">actions/help</a
            ><button type="button" class="hidden toggle-subnav btn btn-link">
              <span class="glyphicon glyphicon-plus"></span>
            </button>
            <div class="hidden" id="actions/help_sub">
              <div class="member-type">Methods</div>
              <ul class="inner">
                <li>
                  <a href="actions_help.html#.argumentsHelp">argumentsHelp</a>
                </li>
                <li><a href="actions_help.html#.desc">desc</a></li>
                <li><a href="actions_help.html#.help">help</a></li>
                <li>
                  <a href="actions_help.html#.optionsHelp">optionsHelp</a>
                </li>
                <li><a href="actions_help.html#.usage">usage</a></li>
              </ul>
            </div>
          </li>
          <li>
            <a href="actions_install.html">actions/install</a
            ><button type="button" class="hidden toggle-subnav btn btn-link">
              <span class="glyphicon glyphicon-plus"></span>
            </button>
            <div class="hidden" id="actions/install_sub">
              <div class="member-type">Methods</div>
              <ul class="inner">
                <li>
                  <a href="actions_install.html#.bowerInstall">bowerInstall</a>
                </li>
                <li>
                  <a href="actions_install.html#.installDependencies"
                    >installDependencies</a
                  >
                </li>
                <li>
                  <a href="actions_install.html#.npmInstall">npmInstall</a>
                </li>
                <li>
                  <a href="actions_install.html#.scheduleInstallTask"
                    >scheduleInstallTask</a
                  >
                </li>
                <li>
                  <a href="actions_install.html#.yarnInstall">yarnInstall</a>
                </li>
              </ul>
            </div>
          </li>
          <li>
            <a href="actions_spawn-command.html">actions/spawn-command</a
            ><button type="button" class="hidden toggle-subnav btn btn-link">
              <span class="glyphicon glyphicon-plus"></span>
            </button>
            <div class="hidden" id="actions/spawn-command_sub">
              <div class="member-type">Methods</div>
              <ul class="inner">
                <li>
                  <a href="actions_spawn-command.html#.spawnCommand"
                    >spawnCommand</a
                  >
                </li>
                <li>
                  <a href="actions_spawn-command.html#.spawnCommandSync"
                    >spawnCommandSync</a
                  >
                </li>
              </ul>
            </div>
          </li>
          <li>
            <a href="actions_user.html">actions/user</a
            ><button type="button" class="hidden toggle-subnav btn btn-link">
              <span class="glyphicon glyphicon-plus"></span>
            </button>
            <div class="hidden" id="actions/user_sub">
              <div class="member-type">Methods</div>
              <ul class="inner">
                <li><a href="actions_user.html#.git.email">git.email</a></li>
                <li><a href="actions_user.html#.git.name">git.name</a></li>
                <li>
                  <a href="actions_user.html#.github.username"
                    >github.username</a
                  >
                </li>
              </ul>
            </div>
          </li>
        </ul>
      </div>
      <div class="lnb-api hidden">
        <h3><a href="global.html">Global</a></h3>
      </div>
    </nav>
    <div id="resizer"></div>

    <div class="main" id="main">
      <section>
        <article>
          <pre class="prettyprint source linenums"><code>'use strict';
const fs = require('fs');
const path = require('path');
const os = require('os');
const EventEmitter = require('events');
const assert = require('assert');
const _ = require('lodash');
const findUp = require('find-up');
const semver = require('semver');
const readPkgUp = require('read-pkg-up');
const chalk = require('chalk');
const makeDir = require('make-dir');
const minimist = require('minimist');
const runAsync = require('run-async');
const through = require('through2');
const createDebug = require('debug');

const Conflicter = require('./util/conflicter');
const Storage = require('./util/storage');
const promptSuggestion = require('./util/prompt-suggestion');

const EMPTY = '@@_YEOMAN_EMPTY_MARKER_@@';
const debug = createDebug('yeoman:generator');
const ENV_VER_WITH_VER_API = '3.0.0';

// Ensure a prototype method is a candidate run by default
const methodIsValid = function(name) {
  return name.charAt(0) !== '_' &amp;&amp; name !== 'constructor';
};

// New runWithOptions should take precedence if exists.
const runGenerator = generator => {
  if (generator.runWithOptions) {
    generator.runWithOptions();
  } else {
    generator.run();
  }
};

/**
 * Queue options.
 * @typedef {Object} QueueOptions
 * @property {string} [queueName] - Name of the queue.
 * @property {boolean} [once] - Execute only once by namespace and taskName.
 * @property {boolean} [run] - Run the queue if not running yet.
 */

/**
 * Task options.
 * @typedef {QueueOptions} TaskOptions
 * @property {Function} [reject] - Reject callback.
 */

/**
 * Priority object.
 * @typedef {QueueOptions} Priority
 * @property {string} priorityName - Name of the priority.
 * @property {string} [before] - The queue which this priority should be added before.
 */

/**
 * Complete Task object.
 * @typedef {TaskOptions} Task
 * @property {WrappedMethod} method - Function to be queued.
 * @property {string} taskName - Name of the task.
 */

/**
 * RunAsync creates a promise and executes wrappedMethod inside the promise.
 * It replaces async property of the wrappedMethod's context with one RunAsync provides.
 * async() simulates an async function by creating a callback.
 *
 * It supports promises/async and sync functions.
 * - Promises/async: forward resolve/reject from the runAsync promise to the
 *   promise returned by the wrappedMethod.
 * - Sync functions: resolves with the returned value.
 *   Can be a promise for chaining
 * - Sync functions with callback (done = this.async()) calls:
 *   Reject with done(rejectValue) first argument
 *   Resolve with done(undefined, resolveValue) second argument
 * - Callback must called when 'async()' was called inside a sync function.
 * - Callback can be ignored when 'async()' was called inside a async function.
 * @typedef {Function} WrappedMethod
 */

class Generator extends EventEmitter {
  // If for some reason environment adds more queues, we should use or own for stability.
  static get queues() {
    return [
      'initializing',
      'prompting',
      'configuring',
      'default',
      'writing',
      'conflicts',
      'install',
      'end'
    ];
  }

  /**
   * @classdesc The `Generator` class provides the common API shared by all generators.
   * It define options, arguments, file, prompt, log, API, etc.
   *
   * It mixes into its prototype all the methods found in the `actions/` mixins.
   *
   * Every generator should extend this base class.
   *
   * @constructor
   * @mixes actions/help
   * @mixes actions/install
   * @mixes actions/spawn-command
   * @mixes actions/user
   * @mixes nodejs/EventEmitter
   *
   * @param {string[]} args           - Provide arguments at initialization
   * @param {Object} options          - Provide options at initialization
   * @param {Priority[]} [options.customPriorities] - Custom priorities
   *
   * @property {Object}   env         - the current Environment being run
   * @property {String}   resolved    - the path to the current generator
   * @property {String}   description - Used in `--help` output
   * @property {String}   appname     - The application name
   * @property {Storage}  config      - `.yo-rc` config file manager
   * @property {Object}   fs          - An instance of {@link https://github.com/SBoudrias/mem-fs-editor Mem-fs-editor}
   * @property {Function} log         - Output content through Interface Adapter
   *
   * @example
   * const Generator = require('yeoman-generator');
   * module.exports = class extends Generator {
   *   writing() {
   *     this.fs.write(this.destinationPath('index.js'), 'const foo = 1;');
   *   }
   * };
   */
  constructor(args, options) {
    super();

    if (!Array.isArray(args)) {
      options = args;
      args = [];
    }

    options = options || {};
    this.options = options;
    this._initOptions = _.clone(options);
    this._args = args || [];
    this._options = {};
    this._arguments = [];
    this._composedWith = [];
    this._transformStreams = [];

    this.option('help', {
      type: Boolean,
      alias: 'h',
      description: "Print the generator's options and usage"
    });

    this.option('skip-cache', {
      type: Boolean,
      description: 'Do not remember prompt answers',
      default: false
    });

    this.option('skip-install', {
      type: Boolean,
      description: 'Do not automatically install dependencies',
      default: false
    });

    this.option('force-install', {
      type: Boolean,
      description: 'Fail on install dependencies error',
      default: false
    });

    this.resolved = this.options.resolved || __dirname;
    this.env = this.options.env;

    // Make sure we have a full featured environment.
    try {
      const Environment = require('yeoman-environment');
      if (!this.env) {
        this.env = Environment.createEnv();
      } else if (Object.getPrototypeOf(this.env) === Object.prototype) {
        debug('Converting env from a simple object to an Environment');
        const env = Environment.createEnv();
        Object.assign(env, this.env);
        this.env = env;
      } else {
        Environment.enforceUpdate(this.env);
      }
    } catch (error) {
      const env = this.env;
      if (!env) {
        throw new Error('This generator requires an environment.');
      }

      if (Object.getPrototypeOf(this.env) === Object.prototype) {
        console.log(
          'Current Environment is a plain object, some features can be missing'
        );
      }

      // Ensure the environment support features this yeoman-generator version require.
      if (!env.adapter || !env.runLoop || !env.sharedFs) {
        throw new Error(
          "Current environment doesn't provides some necessary feature this generator needs"
        );
      }
    }

    try {
      this.fs = this.env.fs || require('mem-fs-editor').create(this.env.sharedFs);
    } catch (_) {
      throw new Error(
        "Current environment don't provides some necessary feature this generator needs"
      );
    }

    this.description = this.description || '';

    // Place holder for run-async callback.
    this.async = () => () => {};

    this.conflicter = new Conflicter(this.env.adapter, this.options.force, {
      bail: this.options.bail,
      ignoreWhitespace: this.options.whitespace,
      skipRegenerate: this.options.skipRegenerate,
      dryRun: this.options.dryRun
    });

    // Mirror the adapter log method on the generator.
    //
    // example:
    // this.log('foo');
    // this.log.error('bar');
    this.log = this.env.adapter.log;

    // Add convenience debug object
    this._debug = createDebug(this.options.namespace || 'yeoman:unknownnamespace');

    // Determine the app root
    this.contextRoot = this.env.cwd;
    this._destinationRoot = this.options.destinationRoot;

    if (this.options.localConfigOnly) {
      debug('Using local configurations only');
    } else if (!this._destinationRoot) {
      let rootPath = findUp.sync('.yo-rc.json', {
        cwd: this.env.cwd
      });
      rootPath = rootPath ? path.dirname(rootPath) : this.env.cwd;

      if (rootPath !== this.env.cwd) {
        this.log(
          [
            '',
            'Just found a `.yo-rc.json` in a parent directory.',
            'Setting the project root at: ' + rootPath
          ].join('\n')
        );
        this.destinationRoot(rootPath);
      }
    }

    this.appname = this.determineAppname();
    this.config = this._getStorage();
    this._globalConfig = this._getGlobalStorage();

    // Ensure source/destination path, can be configured from subclasses
    this.sourceRoot(path.join(path.dirname(this.resolved), 'templates'));

    // Queues map: generator's queue name => grouped-queue's queue name (custom name)
    this._queues = {};

    // Add original queues.
    Generator.queues.forEach(queue => {
      this._queues[queue] = { priorityName: queue, queueName: queue };
    });

    // Add custom queues
    if (Array.isArray(this.options.customPriorities)) {
      const customPriorities = this.options.customPriorities.map(customPriority => {
        // Keep backward compatibility with name
        const newPriority = { priorityName: customPriority.name, ...customPriority };
        delete newPriority.name;
        return newPriority;
      });

      // Sort customPriorities, a referenced custom queue must be added before the one that reference it.
      customPriorities.sort((a, b) => {
        if (a.priorityName === b.priorityName) {
          throw new Error(`Duplicate custom queue ${a.name}`);
        }

        if (a.priorityName === b.before) {
          return -1;
        }

        if (b.priorityName === a.before) {
          return 1;
        }

        return 0;
      });

      // Add queue to runLoop
      customPriorities.forEach(customQueue => {
        customQueue.queueName =
          customQueue.queueName ||
          `${this.options.namespace}#${customQueue.priorityName}`;
        debug(`Registering custom queue ${customQueue.queueName}`);
        this._queues[customQueue.priorityName] = customQueue;

        if (this.env.runLoop.queueNames.includes(customQueue.queueName)) {
          return;
        }

        // Backwards compatibilitiy with grouped-queue &lt; 1.0.0
        if (!this.env.runLoop.addSubQueue) {
          let SubQueue;
          try {
            SubQueue = require('grouped-queue/lib/subqueue');
          } catch (error) {
            throw new Error(
              "The running environment doesn't have the necessary features to run this generator. Update it and run again."
            );
          }

          this.env.runLoop.addSubQueue = function(name, before) {
            if (this.__queues__[name]) {
              // Sub-queue already exists
              return;
            }

            if (!before) {
              // Add at last place.
              this.__queues__[name] = new SubQueue();
              this.queueNames.push(name);
              return;
            }

            if (!this.__queues__[before] || _.indexOf(this.queueNames, before) === -1) {
              throw new Error('sub-queue ' + before + ' not found');
            }

            const current = this.__queues__;
            const currentNames = Object.keys(current);
            // Recreate the queue with new order.
            this.__queues__ = {};
            currentNames.forEach(currentName => {
              if (currentName === before) {
                this.__queues__[name] = new SubQueue();
              }

              this.__queues__[currentName] = current[currentName];
            });

            // Recreate queueNames
            this.queueNames = Object.keys(this.__queues__);
          };
        }

        let beforeQueue = customQueue.before
          ? this._queues[customQueue.before].queueName
          : undefined;
        this.env.runLoop.addSubQueue(customQueue.queueName, beforeQueue);
      });
    }
  }

  checkEnvironmentVersion(packageDependency, version) {
    if (version === undefined) {
      version = packageDependency;
      packageDependency = 'yeoman-environment';
    }

    version = version || ENV_VER_WITH_VER_API;
    const returnError = currentVersion => {
      return new Error(
        `This generator (${this.options.namespace}) requires ${packageDependency} at least ${version}, current version is ${currentVersion}`
      );
    };

    if (!this.env.getVersion) {
      if (!this.options.ignoreVersionCheck) {
        throw returnError(`less than ${ENV_VER_WITH_VER_API}`);
      }

      console.warn(
        `It's not possible to check version with running Environment less than ${ENV_VER_WITH_VER_API}`
      );
      console.warn('Some features may be missing');
      if (semver.lte(version, '2.8.1')) {
        return undefined;
      }

      return false;
    }

    let runningVersion = this.env.getVersion(packageDependency);
    if (runningVersion !== undefined &amp;&amp; semver.lte(version, runningVersion)) {
      return true;
    }

    if (this.options.ignoreVersionCheck) {
      console.warn(
        `Current ${packageDependency} is not compatible with current generator, min required: ${version} current version: ${runningVersion}. Some features may be missing.`
      );
      return false;
    }

    throw returnError(runningVersion);
  }

  /**
   * Convenience debug method
   *
   * @param  {any} args parameters to be passed to debug
   */
  debug(...args) {
    this._debug(...args);
  }

  /**
   * Prompt user to answer questions. The signature of this method is the same as {@link https://github.com/SBoudrias/Inquirer.js Inquirer.js}
   *
   * On top of the Inquirer.js API, you can provide a `{cache: true}` property for
   * every question descriptor. When set to true, Yeoman will store/fetch the
   * user's answers as defaults.
   *
   * @param  {array} questions  Array of question descriptor objects. See {@link https://github.com/SBoudrias/Inquirer.js/blob/master/README.md Documentation}
   * @return {Promise} prompt promise
   */
  prompt(questions) {
    questions = promptSuggestion.prefillQuestions(this._globalConfig, questions);
    questions = promptSuggestion.prefillQuestions(this.config, questions);

    return this.env.adapter.prompt(questions).then(answers => {
      if (!this.options['skip-cache'] &amp;&amp; !this.options.skipCache) {
        promptSuggestion.storeAnswers(this._globalConfig, questions, answers, false);
        promptSuggestion.storeAnswers(this.config, questions, answers, true);
      }

      return answers;
    });
  }

  /**
   * Adds an option to the set of generator expected options, only used to
   * generate generator usage. By default, generators get all the cli options
   * parsed by nopt as a `this.options` hash object.
   *
   * @param {String} name - Option name
   * @param {Object} config - Option options
   * @param {any} config.type - Either Boolean, String or Number
   * @param {string} [config.description] - Description for the option
   * @param {any} [config.default] - Default value
   * @param {any} [config.alias] - Option name alias (example `-h` and --help`)
   * @param {any} [config.hide] - Boolean whether to hide from help
   * @return {this} This generator
   */
  option(name, config) {
    config = config || {};

    // Alias default to defaults for backward compatibility.
    if ('defaults' in config) {
      config.default = config.defaults;
    }

    config.description = config.description || config.desc;

    _.defaults(config, {
      name,
      description: 'Description for ' + name,
      type: Boolean,
      hide: false
    });

    // Check whether boolean option is invalid (starts with no-)
    const boolOptionRegex = /^no-/;
    if (config.type === Boolean &amp;&amp; name.match(boolOptionRegex)) {
      const simpleName = name.replace(boolOptionRegex, '');
      return this.emit(
        'error',
        new Error(
          [
            `Option name ${chalk.yellow(name)} cannot start with ${chalk.red('no-')}\n`,
            `Option name prefixed by ${chalk.yellow('--no')} are parsed as implicit`,
            ` boolean. To use ${chalk.yellow('--' + name)} as an option, use\n`,
            chalk.cyan(`  this.option('${simpleName}', {type: Boolean})`)
          ].join('')
        )
      );
    }

    if (this._options[name] === null || this._options[name] === undefined) {
      this._options[name] = config;
    }

    this.parseOptions();
    return this;
  }

  /**
   * Adds an argument to the class and creates an attribute getter for it.
   *
   * Arguments are different from options in several aspects. The first one
   * is how they are parsed from the command line, arguments are retrieved
   * based on their position.
   *
   * Besides, arguments are used inside your code as a property (`this.argument`),
   * while options are all kept in a hash (`this.options`).
   *
   *
   * @param {String} name - Argument name
   * @param {Object} config - Argument options
   * @param {any} config.type - String, Number, Array, or Object
   * @param {string} [config.description] - Description for the argument
   * @param {boolean} [config.required] - required` Boolean whether it is required
   * @param {boolean} [config.optional] - Boolean whether it is optional
   * @param {any} [config.default] - Default value for this argument
   * @return {this} This generator
   */
  argument(name, config) {
    config = config || {};

    // Alias default to defaults for backward compatibility.
    if ('defaults' in config) {
      config.default = config.defaults;
    }

    config.description = config.description || config.desc;

    _.defaults(config, {
      name,
      required: config.default === null || config.default === undefined,
      type: String
    });

    this._arguments.push(config);

    this.parseOptions();
    return this;
  }

  parseOptions() {
    const minimistDef = {
      string: [],
      boolean: [],
      alias: {},
      default: {}
    };

    _.each(this._options, option => {
      if (option.type === Boolean) {
        minimistDef.boolean.push(option.name);
        if (!('default' in option) &amp;&amp; !option.required) {
          minimistDef.default[option.name] = EMPTY;
        }
      } else {
        minimistDef.string.push(option.name);
      }

      if (option.alias) {
        minimistDef.alias[option.alias] = option.name;
      }

      // Only apply default values if we don't already have a value injected from
      // the runner
      if (option.name in this._initOptions) {
        minimistDef.default[option.name] = this._initOptions[option.name];
      } else if (option.alias &amp;&amp; option.alias in this._initOptions) {
        minimistDef.default[option.name] = this._initOptions[option.alias];
      } else if ('default' in option) {
        minimistDef.default[option.name] = option.default;
      }
    });

    const parsedOpts = minimist(this._args, minimistDef);

    // Parse options to the desired type
    _.each(parsedOpts, (option, name) => {
      // Manually set value as undefined if it should be.
      if (option === EMPTY) {
        parsedOpts[name] = undefined;
        return;
      }

      if (this._options[name] &amp;&amp; option !== undefined) {
        parsedOpts[name] = this._options[name].type(option);
      }
    });

    // Parse positional arguments to valid options
    this._arguments.forEach((config, index) => {
      let value;
      if (index >= parsedOpts._.length) {
        if (config.name in this._initOptions) {
          value = this._initOptions[config.name];
        } else if ('default' in config) {
          value = config.default;
        } else {
          return;
        }
      } else if (config.type === Array) {
        value = parsedOpts._.slice(index, parsedOpts._.length);
      } else {
        value = config.type(parsedOpts._[index]);
      }

      parsedOpts[config.name] = value;
    });

    // Make the parsed options available to the instance
    Object.assign(this.options, parsedOpts);
    this.args = parsedOpts._;
    this.arguments = parsedOpts._;

    // Make sure required args are all present
    this.checkRequiredArgs();
  }

  checkRequiredArgs() {
    // If the help option was provided, we don't want to check for required
    // arguments, since we're only going to print the help message anyway.
    if (this.options.help) {
      return;
    }

    // Bail early if it's not possible to have a missing required arg
    if (this.args.length > this._arguments.length) {
      return;
    }

    this._arguments.forEach((config, position) => {
      // If the help option was not provided, check whether the argument was
      // required, and whether a value was provided.
      if (config.required &amp;&amp; position >= this.args.length) {
        return this.emit(
          'error',
          new Error(`Did not provide required argument ${chalk.bold(config.name)}!`)
        );
      }
    });
  }

  /**
   * Schedule methods on a run queue.
   *
   * @param {Function|Object} method: Method to be scheduled or object with function properties.
   * @param {String} [methodName]: Name of the method (task) to be scheduled.
   * @param {String} [queueName]: Name of the queue to be scheduled on.
   * @param {Function} [reject]: Reject callback.
   */
  queueMethod(method, methodName, queueName, reject) {
    if (typeof queueName === 'function') {
      reject = queueName;
      queueName = 'default';
    } else {
      queueName = queueName || 'default';
    }

    if (!_.isFunction(method)) {
      if (typeof methodName === 'function') {
        reject = methodName;
        methodName = undefined;
      }

      this.queueTaskGroup(method, {
        queueName: methodName,
        reject
      });
      return;
    }

    this.queueTask({
      method,
      taskName: methodName,
      queueName,
      reject
    });
  }

  /**
   * Schedule methods on a run queue.
   *
   * @param {Object}          taskGroup: Object containing tasks.
   * @param {TaskOptions} [taskOptions]: options.
   */
  queueTaskGroup(taskGroup, taskOptions) {
    const self = this;
    // Run each queue items
    _.each(taskGroup, (newMethod, newMethodName) => {
      if (!_.isFunction(newMethod) || !methodIsValid(newMethodName)) return;

      self.queueTask({
        ...taskOptions,
        method: newMethod,
        taskName: newMethodName
      });
    });
  }

  /**
   * Schedule tasks on a run queue.
   *
   * @param {Task} task: Task to be queued.
   */
  queueTask(task) {
    const reject = task.reject;
    const queueName = task.queueName || 'default';
    const methodName = task.taskName;
    const method = task.method;
    const once = task.once ? methodName : undefined;

    const priority = Object.entries(this._queues).find(
      ([_, opts]) => opts.queueName === queueName
    );
    const priorityName = priority ? priority[0] : undefined;

    const self = this;
    const runLoop = this.env.runLoop;
    let namespace = '';
    if (self.options &amp;&amp; self.options.namespace) {
      namespace = self.options.namespace;
    }

    debug(
      `Queueing ${namespace}#${methodName} with options %o`,
      _.omit(task, ['method'])
    );
    runLoop.add(
      queueName,
      taskCompleted => {
        debug(`Running ${namespace}#${methodName}`);
        self.emit(`method:${methodName}`);
        const taskCancelled = task.cancellable &amp;&amp; !self._running;

        runAsync(function() {
          if (taskCancelled) {
            return Promise.resolve();
          }

          self.async = () => this.async();
          self.runningState = { namespace, queueName, methodName };
          return method.apply(self, self.args);
        })()
          .then(function() {
            if (taskCancelled) {
              taskCompleted();
              return;
            }

            delete self.runningState;
            const eventName = `done$${namespace || 'unknownnamespace'}#${methodName}`;
            debug(`Emiting event ${eventName}`);
            self.env.emit(eventName, {
              namespace,
              generator: self,
              queueName,
              priorityName
            });
            taskCompleted();
          })
          .catch(err => {
            debug(`An error occured while running ${namespace}#${methodName}`, err);
            if (reject) {
              debug('Rejecting task promise, queue will continue normally');
              reject(err);
              taskCompleted();
              return;
            }

            delete self.runningState;
            if (runLoop.pause) {
              runLoop.pause();
            }

            // Ensure we emit the error event outside the promise context so it won't be
            // swallowed when there's no listeners.
            setImmediate(() => {
              self.emit('error', err);
            });
          });
      },
      { once, run: task.run }
    );
  }

  /**
   * Ignore cancellable tasks.
   */
  cancelCancellableTasks() {
    this._running = false;
  }

  /**
   * Runs the generator, scheduling prototype methods on a run queue. Method names
   * will determine the order each method is run. Methods without special names
   * will run in the default queue.
   *
   * Any method named `constructor` and any methods prefixed by a `_` won't be scheduled.
   *
   * @param {Function} [cb] Deprecated: prefer to use the promise interface
   * @return {Promise} Resolved once the process finish
   */
  run(cb) {
    const options = { forwardErrorToEnvironment: false };
    const promise = this.runWithOptions(options);

    // Maintain backward compatibility with the callback function
    if (_.isFunction(cb)) {
      return promise.then(cb, cb);
    }

    return promise;
  }

  /**
   * Alternative implementation of run() with a different api.
   * Api for run is stable for old generators.
   *
   * Runs the generator, scheduling prototype methods on a run queue. Method names
   * will determine the order each method is run. Methods without special names
   * will run in the default queue.
   *
   * Any method named `constructor` and any methods prefixed by a `_` won't be scheduled.
   *
   * @private
   * @param {Object} [options] Options.
   * @param {Boolean} [options.forwardErrorToEnvironment=true] Handle errors and forward the error on environment.
   * @return {Promise} Resolved once the queue is cleared.
   */
  runWithOptions(options = {}) {
    const forwardErrorToEnvironment =
      options.forwardErrorToEnvironment === undefined
        ? this.env.options &amp;&amp; this.env.options.newErrorHandler
        : options.forwardErrorToEnvironment;

    const promise = new Promise((resolve, reject) => {
      const self = this;
      this._running = true;
      this.debug('Generator is starting');
      this.emit('run');

      // Add an error listener to reject the promise
      this.on('error', reject);

      const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(this));
      const validMethods = methods.filter(methodIsValid);
      if (!validMethods.length) {
        this.emit(
          'error',
          new Error('This Generator is empty. Add at least one method for it to run.')
        );
      }

      this.env.runLoop.once('end', () => {
        this.debug('Generator has ended');
        this.emit('end');
        resolve();
      });

      function addInQueue(name) {
        const property = Object.getOwnPropertyDescriptor(
          Object.getPrototypeOf(self),
          name
        );
        const item = property.value ? property.value : property.get.call(self);

        const priority = self._queues[name];
        let taskOptions = { ...priority, cancellable: true, run: false };

        // Name points to a function; run it!
        if (typeof item === 'function') {
          taskOptions.taskName = name;
          taskOptions.method = item;
          return self.queueTask(taskOptions);
        }

        // Not a queue hash; stop
        if (!priority) {
          return;
        }

        self.queueTaskGroup(item, taskOptions);
      }

      validMethods.forEach(addInQueue);

      const writeFiles = () => {
        this.env.runLoop.add('conflicts', this._writeFiles.bind(this), {
          once: 'write memory fs to disk'
        });
      };

      this.env.sharedFs.on('change', writeFiles);
      writeFiles();

      // Add the default conflicts handling
      this.env.runLoop.add('conflicts', done => {
        this.conflicter.resolve(err => {
          if (err) {
            this.emit('error', err);
          }

          done();
        });
      });

      this._composedWith.forEach(runGenerator);
    });

    if (forwardErrorToEnvironment) {
      return promise.catch(err => {
        this.env.emit('error', err);
      });
    }

    return promise;
  }

  /**
   * Compose this generator with another one.
   * @param  {String|Object|Array} generator  The path to the generator module or an object (see examples)
   * @param  {Object}  [options]   The options passed to the Generator
   * @param  {boolean} [returnNewGenerator] Returns the created generator instead of returning this.
   * @return {this|Object}    This generator or the composed generator when returnNewGenerator=true
   *
   * @example &lt;caption>Using a peerDependency generator&lt;/caption>
   * this.composeWith('bootstrap', { sass: true });
   *
   * @example &lt;caption>Using a direct dependency generator&lt;/caption>
   * this.composeWith(require.resolve('generator-bootstrap/app/main.js'), { sass: true });
   *
   * @example &lt;caption>Passing a Generator class&lt;/caption>
   * this.composeWith({ Generator: MyGenerator, path: '../generator-bootstrap/app/main.js' }, { sass: true });
   */
  composeWith(generator, options, returnNewGenerator = false) {
    if (typeof options === 'boolean') {
      returnNewGenerator = options;
      options = {};
    }

    const returnCompose = ret => (returnNewGenerator ? ret : this);

    let instantiatedGenerator;

    if (Array.isArray(generator)) {
      const generators = generator.map(gen => this.composeWith(gen, options));
      return returnCompose(generators);
    }

    const instantiate = (Generator, path) => {
      if (path === 'unknown') {
        Generator.resolved = path;
      } else {
        Generator.resolved = require.resolve(path);
      }

      Generator.namespace = this.env.namespace(path);

      return this.env.instantiate(Generator, {
        options,
        arguments: options.arguments
      });
    };

    options = options || {};

    // Pass down the default options so they're correctly mirrored down the chain.
    options = _.extend(
      {
        skipInstall: this.options.skipInstall || this.options['skip-install'],
        'skip-install': this.options.skipInstall || this.options['skip-install'],
        skipCache: this.options.skipCache || this.options['skip-cache'],
        'skip-cache': this.options.skipCache || this.options['skip-cache'],
        forceInstall: this.options.forceInstall || this.options['force-install'],
        'force-install': this.options.forceInstall || this.options['force-install'],
        destinationRoot: this._destinationRoot
      },
      options
    );

    if (typeof generator === 'string') {
      try {
        const GeneratorImport = require(generator); // eslint-disable-line import/no-dynamic-require
        const Generator =
          typeof GeneratorImport.default === 'function'
            ? GeneratorImport.default
            : GeneratorImport;

        instantiatedGenerator = instantiate(Generator, generator);
      } catch (err) {
        if (err.code === 'MODULE_NOT_FOUND') {
          instantiatedGenerator = this.env.create(generator, {
            options,
            arguments: options.arguments
          });
        } else {
          throw err;
        }
      }
    } else {
      assert(
        generator.Generator,
        `${chalk.red('Missing Generator property')}\n` +
          `When passing an object to Generator${chalk.cyan(
            '#composeWith'
          )} include the generator class to run in the ${chalk.cyan(
            'Generator'
          )} property\n\n` +
          `this.composeWith({\n` +
          `  ${chalk.yellow('Generator')}: MyGenerator,\n` +
          `  ...\n` +
          `});`
      );
      assert(
        typeof generator.path === 'string',
        `${chalk.red('path property is not a string')}\n` +
          `When passing an object to Generator${chalk.cyan(
            '#composeWith'
          )} include the path to the generators files in the ${chalk.cyan(
            'path'
          )} property\n\n` +
          `this.composeWith({\n` +
          `  ${chalk.yellow('path')}: '../my-generator',\n` +
          `  ...\n` +
          `});`
      );
      instantiatedGenerator = instantiate(generator.Generator, generator.path);
    }

    if (!instantiatedGenerator) {
      return returnCompose(instantiatedGenerator);
    }

    if (this._running) {
      runGenerator(instantiatedGenerator);
    } else {
      this._composedWith.push(instantiatedGenerator);
    }

    return returnCompose(instantiatedGenerator);
  }

  /**
   * Determine the root generator name (the one who's extending Generator).
   * @return {String} The name of the root generator
   */
  rootGeneratorName() {
    const pkg = readPkgUp.sync({ cwd: this.resolved }).pkg;
    return pkg ? pkg.name : '*';
  }

  /**
   * Determine the root generator version (the one who's extending Generator).
   * @return {String} The version of the root generator
   */
  rootGeneratorVersion() {
    const pkg = readPkgUp.sync({ cwd: this.resolved }).pkg;
    return pkg ? pkg.version : '0.0.0';
  }

  /**
   * Return a storage instance.
   * @param  {String} storePath  The path of the json file
   * @param  {String} [path] The name in which is stored inside the json
   * @param  {String} [lodashPath] Treat path as an lodash path
   * @return {Storage} json storage
   */
  createStorage(storePath, path, lodashPath = false) {
    storePath = this.destinationPath(storePath);
    return new Storage(path, this.fs, storePath, lodashPath);
  }

  /**
   * Return a storage instance.
   * @param  {String} [rootName] The rootName in which is stored inside .yo-rc.json
   * @return {Storage} Generator storage
   * @private
   */
  _getStorage(rootName = this.rootGeneratorName()) {
    const storePath = path.join(this.destinationRoot(), '.yo-rc.json');
    return new Storage(rootName, this.fs, storePath);
  }

  /**
   * Setup a globalConfig storage instance.
   * @return {Storage} Global config storage
   * @private
   */
  _getGlobalStorage() {
    // When localConfigOnly === true simulate a globalConfig at local dir
    const globalStorageDir = this.options.localConfigOnly
      ? this.destinationRoot()
      : os.homedir();
    const storePath = path.join(globalStorageDir, '.yo-rc-global.json');
    const storeName = `${this.rootGeneratorName()}:${this.rootGeneratorVersion()}`;
    return new Storage(storeName, this.fs, storePath);
  }

  /**
   * Change the generator destination root directory.
   * This path is used to find storage, when using a file system helper method (like
   * `this.write` and `this.copy`)
   * @param  {String} rootPath new destination root path
   * @param  {Boolean} skipEnvironment - don't update the environment cwd/chdir.
   * @return {String}          destination root path
   */
  destinationRoot(rootPath, skipEnvironment = false) {
    if (typeof rootPath === 'string') {
      this._destinationRoot = path.resolve(rootPath);

      if (!fs.existsSync(this._destinationRoot)) {
        makeDir.sync(this._destinationRoot);
      }

      if (!skipEnvironment) {
        process.chdir(this._destinationRoot);
        this.env.cwd = this._destinationRoot;
      }

      // Reset the storage
      this.config = this._getStorage();
    }

    return this._destinationRoot || this.env.cwd;
  }

  /**
   * Change the generator source root directory.
   * This path is used by multiples file system methods like (`this.read` and `this.copy`)
   * @param  {String} rootPath new source root path
   * @return {String}          source root path
   */
  sourceRoot(rootPath) {
    if (typeof rootPath === 'string') {
      this._sourceRoot = path.resolve(rootPath);
    }

    return this._sourceRoot;
  }

  /**
   * Join a path to the source root.
   * @param  {...String} dest - path parts
   * @return {String}    joined path
   */
  templatePath(...dest) {
    let filepath = path.join.apply(path, dest);

    if (!path.isAbsolute(filepath)) {
      filepath = path.join(this.sourceRoot(), filepath);
    }

    return filepath;
  }

  /**
   * Join a path to the destination root.
   * @param  {...String} dest - path parts
   * @return {String}    joined path
   */
  destinationPath(...dest) {
    let filepath = path.join.apply(path, dest);

    if (!path.isAbsolute(filepath)) {
      filepath = path.join(this.destinationRoot(), filepath);
    }

    return filepath;
  }

  /**
   * Determines the name of the application.
   *
   * First checks for name in bower.json.
   * Then checks for name in package.json.
   * Finally defaults to the name of the current directory.
   * @return {String} The name of the application
   */
  determineAppname() {
    let appname = this.fs.readJSON(this.destinationPath('bower.json'), {}).name;

    if (!appname) {
      appname = this.fs.readJSON(this.destinationPath('package.json'), {}).name;
    }

    if (!appname) {
      appname = path.basename(this.destinationRoot());
    }

    return appname.replace(/[^\w\s]+?/g, ' ');
  }

  /**
   * Add a transform stream to the commit stream.
   *
   * Most usually, these transform stream will be Gulp plugins.
   *
   * @param  {stream.Transform|stream.Transform[]} streams An array of Transform stream
   * or a single one.
   * @return {this} This generator
   */
  registerTransformStream(streams) {
    assert(streams, 'expected to receive a transform stream as parameter');
    if (!Array.isArray(streams)) {
      streams = [streams];
    }

    this._transformStreams = this._transformStreams.concat(streams);
    return this;
  }

  /**
   * Write memory fs file to disk and logging results
   * @param {Function} done - callback once files are written
   * @private
   */
  _writeFiles(done) {
    const self = this;

    const conflictChecker = through.obj(function(file, enc, cb) {
      const stream = this;

      // If the file has no state requiring action, move on
      if (file.state === null) {
        return cb();
      }

      // Config file should not be processed by the conflicter. Just pass through
      const filename = path.basename(file.path);

      if (filename === '.yo-rc.json' || filename === '.yo-rc-global.json') {
        file.conflicter = 'force';
      }

      self.conflicter.checkForCollision(file, (err, status) => {
        if (err) {
          cb(err);
          return;
        }

        if (status === 'skip') {
          delete file.state;
        } else {
          stream.push(file);
        }

        cb();
      });
      self.conflicter.resolve();
    });

    const transformStreams = this._transformStreams.concat([conflictChecker]);
    this.fs.commit(transformStreams, () => {
      done();
    });
  }
}

// Mixin the actions modules
_.extend(Generator.prototype, require('./actions/install'));
_.extend(Generator.prototype, require('./actions/help'));
_.extend(Generator.prototype, require('./actions/spawn-command'));
Generator.prototype.user = require('./actions/user');

module.exports = Generator;
</code></pre>
        </article>
      </section>
    </div>

    <footer>
      <img
        class="logo"
        src="https://raw.githubusercontent.com/yeoman/yeoman.github.io/source/app/assets/img/logo.png"
        style="width: 127px; height: 14px;"
      />
      <div class="footer-text">BSD license Copyright (c) Google</div>
    </footer>
    <script>
      prettyPrint();
    </script>
    <script src="scripts/jquery.min.js"></script>
    <script src="scripts/tui-doc.js"></script>
    <script src="scripts/linenumber.js"></script>

    <script>
      var id = "_sub".replace(/"/g, "_");
      var selectedApi = document.getElementById(id); // do not use jquery selector
      var $selectedApi = $(selectedApi);

      $selectedApi.removeClass("hidden");
      $selectedApi
        .parent()
        .find(".glyphicon")
        .removeClass("glyphicon-plus")
        .addClass("glyphicon-minus");
      showLnbApi();
    </script>
  </body>
</html>
